import jsPDF from 'jspdf';

export interface JumpPDFData {
  title: string;
  summary?: string;
  content: string;
  createdAt: string;
  structured_plan?: any;
  comprehensive_plan?: any;
  components?: {
    tools?: any[];
    prompts?: any[];
    workflows?: any[];
    blueprints?: any[];
    strategies?: any[];
  };
}

export const generateJumpPDF = (jumpData: JumpPDFData): void => {
  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - 2 * margin;
  let yPosition = margin;

  // Professional color palette matching website design
  const colors = {
    background: [255, 255, 255], // White background
    foreground: [10, 10, 10], // Nearly black text (--foreground: 0 0% 3.9%)
    muted: [115, 115, 115], // Muted text (--muted-foreground: 0 0% 45.1%)
    border: [229, 229, 229], // Border color (--border: 0 0% 89.8%)
    accent: [245, 245, 245], // Light gray accent (--accent: 0 0% 96.1%)
    primary: [23, 23, 23], // Primary dark (--primary: 0 0% 9%)
  } as const;

  // Helper function to add new page if needed
  const checkPageBreak = (neededHeight: number) => {
    if (yPosition + neededHeight > pageHeight - margin) {
      pdf.addPage();
      yPosition = margin + 20; // Account for header on new pages
      addPageHeader();
    }
  };

  // Helper function to wrap text with better line spacing
  const wrapText = (text: string, maxWidth: number, fontSize: number) => {
    pdf.setFontSize(fontSize);
    return pdf.splitTextToSize(text, maxWidth);
  };

  // Add professional page header with JumpinAI logo
  const addPageHeader = () => {
    // Professional header background
    pdf.setFillColor(...colors.accent);
    pdf.rect(0, 0, pageWidth, 18, 'F');
    
    // JumpinAI Logo (left side)
    pdf.setTextColor(...colors.primary);
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text('JumpinAI', margin, 12);
    
    // Generated by text (right side)
    pdf.setTextColor(...colors.muted);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.text('AI-Generated Jump Plan', pageWidth - margin - 40, 12);
    
    // Subtle bottom border
    pdf.setDrawColor(...colors.border);
    pdf.setLineWidth(0.3);
    pdf.line(0, 18, pageWidth, 18);
  };

  // Add main header
  addPageHeader();
  yPosition = 30; // Start after header

  // Compact document title section
  pdf.setTextColor(...colors.foreground);
  pdf.setFontSize(18);
  pdf.setFont('helvetica', 'bold');
  const titleLines = wrapText(jumpData.title, maxWidth, 18);
  pdf.text(titleLines, margin, yPosition);
  yPosition += titleLines.length * 8 + 8;

  // Subtle title underline
  pdf.setDrawColor(...colors.border);
  pdf.setLineWidth(0.8);
  pdf.line(margin, yPosition, margin + maxWidth * 0.4, yPosition);
  yPosition += 15;

  // Compact metadata section
  pdf.setTextColor(...colors.muted);
  pdf.setFontSize(9);
  pdf.setFont('helvetica', 'normal');
  
  // Creation date (left)
  const dateText = new Date(jumpData.createdAt).toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  pdf.text(`Created: ${dateText}`, margin, yPosition);
  
  // AI Generated badge (right) - removed emoji
  pdf.text('AI GENERATED', pageWidth - margin - 30, yPosition);
  
  yPosition += 20;

  // Add summary if available
  if (jumpData.summary) {
    checkPageBreak(20);
    pdf.setTextColor(...colors.muted);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'italic');
    const summaryLines = wrapText(jumpData.summary, maxWidth, 11);
    pdf.text(summaryLines, margin, yPosition);
    yPosition += summaryLines.length * 6 + 15;
  }

  // Process structured plan if available
  const processStructuredPlan = () => {
    if (!jumpData.structured_plan) return;

    checkPageBreak(25);
    pdf.setTextColor(...colors.foreground);
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Implementation Plan', margin, yPosition);
    yPosition += 10;
    
    // Underline
    pdf.setDrawColor(...colors.border);
    pdf.setLineWidth(0.5);
    pdf.line(margin, yPosition, margin + maxWidth * 0.3, yPosition);
    yPosition += 15;

    // Overview
    if (jumpData.structured_plan.overview) {
      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      const overviewLines = wrapText(jumpData.structured_plan.overview, maxWidth, 10);
      pdf.text(overviewLines, margin, yPosition);
      yPosition += overviewLines.length * 5 + 10;
    }

    // Phases
    if (jumpData.structured_plan.phases && jumpData.structured_plan.phases.length > 0) {
      jumpData.structured_plan.phases.forEach((phase: any, index: number) => {
        checkPageBreak(30);
        
        // Phase header
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        const phaseTitle = `Phase ${phase.phase_number || index + 1}: ${phase.title}`;
        const phaseTitleLines = wrapText(phaseTitle, maxWidth, 12);
        pdf.text(phaseTitleLines, margin, yPosition);
        yPosition += phaseTitleLines.length * 6 + 5;

        // Duration
        if (phase.duration) {
          pdf.setTextColor(...colors.muted);
          pdf.setFontSize(9);
          pdf.setFont('helvetica', 'normal');
          pdf.text(`Duration: ${phase.duration}`, margin, yPosition);
          yPosition += 8;
        }

        // Description
        if (phase.description) {
          pdf.setTextColor(...colors.foreground);
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');
          const descLines = wrapText(phase.description, maxWidth, 10);
          pdf.text(descLines, margin, yPosition);
          yPosition += descLines.length * 5 + 8;
        }

        // Tasks
        if (phase.tasks && phase.tasks.length > 0) {
          phase.tasks.forEach((task: any) => {
            checkPageBreak(15);
            pdf.setTextColor(...colors.foreground);
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            
            // Bullet point
            pdf.setFillColor(...colors.primary);
            pdf.circle(margin + 3, yPosition - 1, 1, 'F');
            
            const taskText = typeof task === 'string' ? task : task.description || task.name || 'Task';
            const taskLines = wrapText(taskText, maxWidth - 12, 10);
            pdf.text(taskLines, margin + 10, yPosition);
            yPosition += taskLines.length * 5 + 2;
          });
        }

        yPosition += 8;
      });
    }
  };

  // Process comprehensive plan sections
  const processComprehensivePlan = () => {
    if (!jumpData.comprehensive_plan) return;

    const plan = jumpData.comprehensive_plan;

    // Executive Summary
    if (plan.executive_summary) {
      checkPageBreak(25);
      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Executive Summary', margin, yPosition);
      yPosition += 8;
      
      pdf.setDrawColor(...colors.border);
      pdf.setLineWidth(0.5);
      pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
      yPosition += 10;

      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      const summaryLines = wrapText(plan.executive_summary, maxWidth, 10);
      pdf.text(summaryLines, margin, yPosition);
      yPosition += summaryLines.length * 5 + 15;
    }

    // Key Objectives
    if (plan.key_objectives) {
      checkPageBreak(25);
      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Key Objectives', margin, yPosition);
      yPosition += 8;
      
      pdf.setDrawColor(...colors.border);
      pdf.setLineWidth(0.5);
      pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
      yPosition += 10;

      const objectives = Array.isArray(plan.key_objectives) ? plan.key_objectives : [plan.key_objectives];
      objectives.forEach((objective: string) => {
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        pdf.setFillColor(...colors.primary);
        pdf.circle(margin + 3, yPosition - 1, 1, 'F');
        
        const objLines = wrapText(objective, maxWidth - 12, 10);
        pdf.text(objLines, margin + 10, yPosition);
        yPosition += objLines.length * 5 + 3;
      });
      yPosition += 10;
    }

    // Success Metrics
    if (plan.success_metrics) {
      checkPageBreak(25);
      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Success Metrics', margin, yPosition);
      yPosition += 8;
      
      pdf.setDrawColor(...colors.border);
      pdf.setLineWidth(0.5);
      pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
      yPosition += 10;

      const metrics = Array.isArray(plan.success_metrics) ? plan.success_metrics : [plan.success_metrics];
      metrics.forEach((metric: string) => {
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        pdf.setFillColor(...colors.primary);
        pdf.circle(margin + 3, yPosition - 1, 1, 'F');
        
        const metricLines = wrapText(metric, maxWidth - 12, 10);
        pdf.text(metricLines, margin + 10, yPosition);
        yPosition += metricLines.length * 5 + 3;
      });
      yPosition += 10;
    }
  };

  // Process components (tools, prompts, workflows, blueprints, strategies)
  const processComponents = () => {
    if (!jumpData.components) return;

    // Tools section
    if (jumpData.components.tools && jumpData.components.tools.length > 0) {
      checkPageBreak(25);
      pdf.setTextColor(...colors.foreground);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('AI Tools & Resources', margin, yPosition);
      yPosition += 8;
      
      pdf.setDrawColor(...colors.border);
      pdf.setLineWidth(0.5);
      pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
      yPosition += 10;

      jumpData.components.tools.forEach((tool: any) => {
        checkPageBreak(20);
        
        // Tool name
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(11);
        pdf.setFont('helvetica', 'bold');
        const toolName = tool.name || 'AI Tool';
        pdf.text(toolName, margin, yPosition);
        yPosition += 8;

        // Tool description
        if (tool.description) {
          pdf.setTextColor(...colors.foreground);
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');
          const descLines = wrapText(tool.description, maxWidth, 10);
          pdf.text(descLines, margin, yPosition);
          yPosition += descLines.length * 5 + 5;
        }

        // When to use
        if (tool.when_to_use) {
          pdf.setTextColor(...colors.muted);
          pdf.setFontSize(9);
          pdf.setFont('helvetica', 'italic');
          const whenLines = wrapText(`When to use: ${tool.when_to_use}`, maxWidth, 9);
          pdf.text(whenLines, margin, yPosition);
          yPosition += whenLines.length * 4 + 8;
        }
      });
    }

    // Add other component sections (prompts, workflows, etc.) if they exist
    const componentSections = [
      { key: 'prompts', title: 'AI Prompts' },
      { key: 'workflows', title: 'Workflows' },
      { key: 'blueprints', title: 'Blueprints' },
      { key: 'strategies', title: 'Strategies' }
    ];

    componentSections.forEach(section => {
      const components = jumpData.components?.[section.key as keyof typeof jumpData.components];
      if (components && Array.isArray(components) && components.length > 0) {
        checkPageBreak(25);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        pdf.text(section.title, margin, yPosition);
        yPosition += 8;
        
        pdf.setDrawColor(...colors.border);
        pdf.setLineWidth(0.5);
        pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
        yPosition += 10;

        components.forEach((component: any) => {
          checkPageBreak(15);
          
          // Component title
          pdf.setTextColor(...colors.foreground);
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'bold');
          const title = component.title || component.name || `${section.title.slice(0, -1)}`;
          pdf.text(title, margin, yPosition);
          yPosition += 8;

          // Component description
          if (component.description) {
            pdf.setTextColor(...colors.foreground);
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            const descLines = wrapText(component.description, maxWidth, 10);
            pdf.text(descLines, margin, yPosition);
            yPosition += descLines.length * 5 + 8;
          }
        });
      }
    });
  };

  // Process content - convert markdown to PDF for any remaining text content
  const processContent = (content: string) => {
    if (!content) return;
    
    const lines = content.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      if (!line) {
        yPosition += 5;
        continue;
      }

      // Headers - compact and clean formatting
      if (line.startsWith('# ')) {
        checkPageBreak(25);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(16);
        pdf.setFont('helvetica', 'bold');
        const headerText = line.substring(2).trim();
        const headerLines = wrapText(headerText, maxWidth, 16);
        pdf.text(headerLines, margin, yPosition);
        yPosition += headerLines.length * 7 + 4;
        
        // Subtle underline
        pdf.setDrawColor(...colors.border);
        pdf.setLineWidth(0.5);
        pdf.line(margin, yPosition, margin + maxWidth * 0.25, yPosition);
        yPosition += 8;
        
      } else if (line.startsWith('## ')) {
        checkPageBreak(20);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        const headerText = line.substring(3).trim();
        const headerLines = wrapText(headerText, maxWidth, 14);
        pdf.text(headerLines, margin, yPosition);
        yPosition += headerLines.length * 6 + 6;
        
      } else if (line.startsWith('### ')) {
        checkPageBreak(18);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        const headerText = line.substring(4).trim();
        const headerLines = wrapText(headerText, maxWidth, 12);
        pdf.text(headerLines, margin, yPosition);
        yPosition += headerLines.length * 5 + 5;
        
      } else if (line.startsWith('- ') || line.startsWith('* ')) {
        // Clean bullet points
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        // Simple bullet point
        pdf.setFillColor(...colors.primary);
        pdf.circle(margin + 3, yPosition - 1, 1, 'F');
        
        const bulletText = line.substring(2).trim();
        const bulletLines = wrapText(bulletText, maxWidth - 12, 10);
        pdf.text(bulletLines, margin + 10, yPosition);
        yPosition += bulletLines.length * 5 + 2;
        
      } else if (line.match(/^\d+\. /)) {
        // Numbered lists
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        const numberedLines = wrapText(line, maxWidth, 10);
        pdf.text(numberedLines, margin, yPosition);
        yPosition += numberedLines.length * 5 + 2;
        
      } else if (line.startsWith('**') && line.endsWith('**')) {
        // Bold text sections
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'bold');
        const boldText = line.substring(2, line.length - 2);
        const boldLines = wrapText(boldText, maxWidth, 10);
        pdf.text(boldLines, margin, yPosition);
        yPosition += boldLines.length * 5 + 4;
        
      } else {
        // Regular paragraph - clean and readable
        checkPageBreak(15);
        pdf.setTextColor(...colors.foreground);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        // Clean text processing - remove all symbols that don't render well
        let processedLine = line;
        
        // Remove all emojis and special unicode characters
        processedLine = processedLine.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
        
        // Remove markdown formatting for cleaner PDF text
        processedLine = processedLine.replace(/\*\*(.*?)\*\*/g, '$1');
        processedLine = processedLine.replace(/\*(.*?)\*/g, '$1');
        processedLine = processedLine.replace(/`([^`]+)`/g, '$1');
        
        // Clean up extra whitespace
        processedLine = processedLine.replace(/\s+/g, ' ').trim();
        
        if (processedLine) {
          const paragraphLines = wrapText(processedLine, maxWidth, 10);
          pdf.text(paragraphLines, margin, yPosition);
          yPosition += paragraphLines.length * 5 + 6;
        }
      }
    }
  };

  // Process all sections in order
  processStructuredPlan();
  processComprehensivePlan();
  processComponents();
  
  // Process any remaining markdown content
  if (jumpData.content && !jumpData.structured_plan && !jumpData.comprehensive_plan) {
    processContent(jumpData.content);
  }

  // Add professional footer to all pages
  const pageCount = pdf.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    
    // Footer separator line
    pdf.setDrawColor(...colors.border);
    pdf.setLineWidth(0.3);
    pdf.line(margin, pageHeight - 25, pageWidth - margin, pageHeight - 25);
    
    // Footer content
    pdf.setTextColor(...colors.muted);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    
    // Page number (right)
    pdf.text(`${i} / ${pageCount}`, pageWidth - margin - 20, pageHeight - 15);
    
    // Generated by text (left)
    pdf.text('Generated by JumpinAI', margin, pageHeight - 15);
    
    // Date generated (center)
    const currentDate = new Date().toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric' 
    });
    const centerText = `Generated on ${currentDate}`;
    const centerX = (pageWidth - pdf.getTextWidth(centerText)) / 2;
    pdf.text(centerText, centerX, pageHeight - 15);
  }

  // Download the PDF with clean filename
  const cleanTitle = jumpData.title
    .replace(/[^a-zA-Z0-9\s]/g, '')
    .trim()
    .replace(/\s+/g, '-')
    .toLowerCase()
    .substring(0, 50); // Limit length
  
  const fileName = `${cleanTitle || 'jump-plan'}.pdf`;
  pdf.save(fileName);
};